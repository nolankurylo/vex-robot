#pragma config(Sensor, in1,    Phototrans,     sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  disty,          sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  leftLim,        sensorTouch)
#pragma config(Sensor, dgtl6,  rightLim,       sensorTouch)
#pragma config(Sensor, dgtl10, wallCollision,  sensorDigitalOut)
#pragma config(Sensor, dgtl11, proper_Orient_Distance, sensorDigitalOut)
#pragma config(Sensor, dgtl12, facing_Toofar,  sensorDigitalOut)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightMotor,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Sensor, I2C_1,armEncoder  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool but1; // button one value
bool but2; // button two value
bool leftSwitch; // left limit switch value
bool rightSwitch; // left limit switch value
bool senseLight; // evaluates true if IR light is sensed from beacon

const int light_threshold = 215;


// Changes boolean button variable values as they are pressed.
void getButtonInput() {

	if(SensorValue(button1)) {
		but1 = true;
		but2 = false;
	}

	if(SensorValue(button2)) {
		but2 = true;
		but1 = false;
	}

} // getButtonInput


// Changes boolean limit switch variable values as they are pressed.
void getLimitSwitchInput() {

	if(SensorValue(leftLim)) {
		leftSwitch = true;
		rightSwitch = false;
	}

	if(SensorValue(rightLim)) {
		rightSwitch = true;
		leftSwitch = false;
	}

} // getLimitSwitchInput


// Function to detect 10 Hz IR light from beacon; Credit to Dr. Michael Mcguire
bool monitorLight()
{

	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[Phototrans];
	bool returnValue;

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}

	// Check if light level difference over threshold.
	if ( diffLevelIR1 > light_threshold ) {
		returnValue = true;
		} else {
		returnValue = false;
	}

	return(returnValue);
} // monitorLight


// return distance reading from ultrasonic sensor
int getDistance() {
	return SensorValue(disty);
} // getDistance


task main () {

	SensorValue(facing_Toofar) = true; // Starts with LED lights turned off
	SensorValue(proper_Orient_Distance) = true;

	// finite number of states the robot can be in.
	enum RobotStateType {
		forwards,
		stopped,
		turning,
		connecting,
		obstacle
	};



	RobotStateType robotState = stopped; // robot starts out stopped.




	while(true) {
		getButtonInput();
		getLimitSwitchInput();
		int distance = getDistance();
		senseLight = monitorLight();


		// Engage wall avoidance system if limit switch is triggered.
		// Move backwards, turn, then forwards again.
		if(leftSwitch) {
			motor[leftMotor] = -38;
			motor[rightMotor] = 27;
			wait1Msec(400);
			motor[leftMotor] = 33;
			motor[rightMotor] = 33;
			wait1Msec(900);
			robotState = forwards;
			leftSwitch = false;
		}

		if(rightSwitch) {
			motor[leftMotor] = -38;
			motor[rightMotor] = 27;
			wait1Msec(400);
			motor[leftMotor] = -33;
			motor[rightMotor] = -33;
			wait1Msec(900);
			robotState = forwards;
			rightSwitch = false;
		}



		if(senseLight && distance < 20) {
			robotState = connecting;
		}



		if(but1) {
			robotState = forwards;
			but1 = false;
		}


		if(but2) {
			robotState = turning;
			but2 = false;
		}


		switch(robotState) {


			// All motors off when stopped.
		case stopped:



			senseLight = monitorLight();
			motor[leftMotor] = 0;
			motor[rightMotor] = 0;
			motor[arm] = 0;
			wait1Msec(1000);
			SensorValue(proper_Orient_Distance) = true;

			if(but1) {
				robotState = forwards;
				but1 = false;
			}


			if(but2) {
				robotState = turning;
				but2 = false;
			}
			break;




			// Since motors are facing opposite directions, they will turn opposite for the robot to move forwards.
			// Left and right values skewed for motor inaccuracy.
		case forwards:
			senseLight = monitorLight();
			motor[leftMotor] = 54;
			motor[rightMotor] = -48;


			// Detects walls or other objects
			if(distance < 35 && !senseLight) {
				robotState = obstacle;
			}

			while(senseLight && (distance < 29 && distance > 25)) {
				senseLight = false;
				robotState = turning;
			} // while

			// Detects beacon and connection distance
			if(senseLight && distance < 20) {
				robotState = connecting;
			}

			break;

			// Turn robot and sense IR light from beacon
		case turning:
			senseLight = monitorLight();


			motor[leftMotor] = 33;
			motor[rightMotor] = 33;

			// Sense light in direction of beacon
			if(senseLight) {
				robotState = forwards;
				SensorValue(facing_Toofar) = false;
			}

			break;


		case connecting:
			clearTimer(T3);
			SensorValue[armEncoder] = 0;
			//resetMotorEncoder(arm);
			motor[leftMotor] = 0;
			motor[rightMotor] = 0;



			while(time1[T3] < 3500) {


				while(SensorValue[armEncoder] > 0) {
					motor[arm] = -16;
				} //while



				while(SensorValue[armEncoder] < 270) {
					motor[arm] = 16;
				} //while

			} //while

			while(SensorValue[armEncoder] < 135) {
				motor[arm] = 12;
			} // while

			motor[leftMotor] = -169;
			motor[rightMotor] = 169;
			wait1Msec(600);
			motor[leftMotor] = 0;
			motor[rightMotor] = 0;
			motor[arm] = 0;
			robotState = stopped;
			break;


			// Engage wall avoidance system when necessary.
			// Move backwards, turn, then forwards again.
		case obstacle:
			senseLight = monitorLight();
			clearTimer(T2);


			motor[leftMotor] = -38;
			motor[rightMotor] = 27;
			wait1Msec(400);

			while(time1[T2] < 2900) {
				senseLight = monitorLight();
				if(senseLight) {
					robotState = forwards;
					SensorValue(facing_Toofar) = false;
					break;
				}

				motor[leftMotor] = 33;
				motor[rightMotor] = 33;


			} // while

			robotState = forwards;


		} // switch


	} // while


} // main
